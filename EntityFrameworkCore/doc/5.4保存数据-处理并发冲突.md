#### 处理并发冲突

>**Note**
>
>本页面记录了EF Core中的并发如何工作，以及如何处理应用程序中的并发冲突。有关如何在模型中配置并发令牌的详细信息，请参见[并发标记](2.8并发标记.md)。

>**Tip**
>
>##### 下面的代码时可以下载并运行的[例子](https://github.com/aspnet/EntityFramework.Docs/tree/master/samples/core/Saving/Saving/CascadeDelete/)的一部分。

*数据库并发性 - Database concurrency*指的时多个进程或用户在同一时间访问或修改数据库中相同数据的情况。*Concurrency control - 并发控制*是指在并发更改情况下用于确保数据一致性的特定机制。

EF Core实现*乐观并发控制 - optimistic concurrency control*，意味着它将允许多个进程或用户独立的进行修改，无需同步或锁定开销。在理想情况下，这些变化不会相互干扰，因此能够成功。在最坏的情形下，两个或更多进程将尝试进行冲突更改，应该只有一个成功。

##### EF Core中并发控制如何工作

配置为并发标记的属性被用来实现乐观并发控制：每当在`SaveChanges`期间执行更新或删除操作时，都会将数据库上的并发标记和EF Core读取的原始值进行比较。
* 如果值相匹配，操作就能完成
* 如果值不匹配，EF Core认为另一个用户已经执行了一个冲突操作，终止当前事务

另一个用户已经执行了与当前操作冲突的操作的情况被称为并发冲突。


数据库提供程序负责实现并发标记值的比较。

在关系型数据库中，EF Core包含在任何`UPDATE`或`DELETE`的`WHERE`子句中检查并发标记。在执行语句之后，EF Core读取受影响的行数。

如果没有影响到任何行，则检测到并发冲突，EF Core抛出`DbUpdateConcurrencyException`。

例如，可能希望`Person`的`LastName`为并发标记。那么在更行Person的操作的`WHERE`子句中会包含并发检查：

```sql
UPDATE [Person] SET [FirstName] = @p1
WHERE [PersonId] = @p0 AND [LastName] = @p2;
```

##### 解决并发冲突

继续前面的例子，如果一个用户试着保存对`Person`的修改，但是另外一个用户已经修改了，那么会抛出异常。

此时，应用程序可以简单的通知用户，由于相互冲突的更改，导致更新没有成功，然后继续。但是，最好提示用户确保该记录任然代表同一个person，并重试操作

这是*解决并发冲突*的一个例子