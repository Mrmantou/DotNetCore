#### 断开连接的实体

每个DbContext实例会自动跟踪从数据库返回的实体。对实体的修改在调用SaveChanges时被检测，数据库进行必要的更新。查看[基本的保存](5.1保存数据-基本的保存.md)和[关联数据](5.2保存数据-保存关联数据.md)获取更多详细信息。

然而，有时候实例通过一个context进行查询，然后使用另一个实例进行保存，这通常发生在"断开连接 - disconnected"场景，例如一个应用程序中，实体被查询、发送到客户端，修改，在请求中发送会服务器，然后保存。在这种情况下，第二个context实例需要知道，这个实体是新实体(应该插入)或已存在的实体(应该更新)。

>**Tip**
>
>EF Core只能跟踪具有给定主键值的任何实体的一个实例。避免这个问题的最佳方式是为每个工作单元使用一个短时间的context，这样，context开始是空的，附加实体，保存这些实体，然后释放和丢弃context。

##### 识别新实体

###### 客户端识别新实体

最简单的情况是，客户端通知服务器实体是新的还是现有的。例如，插入新实体的请求与更新现有实体的请求不同。

本节的其余部分将介绍需要其他方式确定是插入还是更新的情况。

###### 使用自动生成的键

自动生成的键值通常用于确定是否需要被插入或更新。如果键没有被设置(就是，仍然为CLR默认值null,0等等)，那么这个实体必然为新实体，需要插入数据库。相反，如果键值已经被设置，那么这个实体已经在之前被保存了，现在需要更新。换句话说，如果键有值，那么这个实体是被查询，发送到客户端，现在已经返回来进行更新。

当实体类型已知时，很容易检查未设置的键：

```csharp
public static bool IsItNew(Blog blog) 
    => blog.BlogId == 0;
```

然而EF也有一个内建的方法来对任何实体类型和键类型进行检查：

```csharp
public static bool IsItNew(DbContext context, object entity) 
    => !context.Entry(entity).IsKeySet;
```

>**Tip**
>
>只要context跟踪实体，就会设置键，即使实体处于Added状态。这有助于遍历实体图并决定如何处理它们，例如在使用TrackGraph API时。键值应该仅以这里显示的方式使用，然后进行任何跟踪实体的调用。

###### 使用其他键

当键值不是自动生成时，需要一些其他机制来识别新实体。