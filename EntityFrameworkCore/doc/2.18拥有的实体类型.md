#### 被拥有的实体类型 Owned Entity Types

EF Core允许创建实体类型只出现在其它实体类型的导航属性中。被称为`owned entity types`。包含`owned entity type`的实体类型是它的`owner`。

##### 显示配置

被拥有实体类型按照约定永远不会被EF Core包含在模型中。可以在`OnModelCreating`中使用`OwnsOne`方法，或使用`OwnedAttribute`进行标注配置类型作为被拥有类型。

在这下面的例子中，`StreetAddress`是个没有标识属性的类型。它作为`Order`类型的一个属性来指明特定订单的送货地址信息。

在被其它实体类型引用时，可以使用`OwnedAttribute`将其视为被拥有的类型：

```csharp
[Owned]
public class StreetAddress
{
    public string Street { get; set; }
    public string City { get; set; }
}
```

```csharp
public class Order
{
    public int Id { get; set; }
    public StreetAddress ShippingAddress { get; set; }
}
```

也可以在`OnModelCreating`中使用`OwnsOne`方法来指明`ShippingAddress`属性是`Order`实体类型的被拥有实体，如果需要，配置其他方面。

```csharp
modelBuilder.Entity<Order>().OwnsOne(p => p.ShippingAddress);
```

如果`ShippingAddress`属性在`Order`类型中是私有的，可以使用string版本的`OwnsOne`方法：

```csharp
modelBuilder.Entity<Order>().OwnsOne(typeof(StreetAddress), "ShippingAddress");
```

##### 隐式键 Implicit keys

通过`OwnsOne`配置或通过导航引用发现的被拥有类型总是与owner存在一对一的关系，然而并不需要因为外键值是唯一的而拥有键值。在前面的例子中，`StreetAddress`类型不需要定义一个键属性。

为了理解EF Core如何跟踪这些对象，可以想象为给被拥有属性创建一个影子属性作为主键。被拥有类型的实例的键值将与拥有者实例的键值相同。

##### 被拥有类型集合 Collections of owned types

>Note:
>
>EF Core2.2的新特性

配置被拥有类型集合需要在`OnModelCreating`使用`OwnsMany`。但是，主键不会按照约定配置，因此需要显式地指定它。对于这些实体类型，通常使用一个复杂的键，拥有者的外键和另一个唯一属性都可以处于影子状态：

```csharp
modelBuilder.Entity<Distributor>().OwnsMany(p => p.ShippingCenters, a =>
{
    a.HasForeignKey("DistributorId");
    a.Property<int>("Id");
    a.HasKey("DistributorId", "Id");
});
```

##### 使用表拆分映射被拥有的类型

在使用关系型数据库是，按照约定被拥有的类型被映射到拥有者相同的表中。这需要将表分成两部分:一些列用于存储owner的数据，一些列用于存储owned entity的数据。这是表分割的一个常见特性。

>**Tip:**
>
>与表拆分一起存储的被拥有类型可以类似地用于EF6中复杂类型的使用。

按照约定，EF Core将owned实体类型属性在数据库中的命名遵循下面的模式`Navigation_OwnedEntityProperty`。因此，`StreetAddress`属性将出现在`Orders`表中名称为`ShippingAddress_Street`和`ShippingAddress_City`。

也可以使用`HasColumnName`方法重命名这些列：

```csharp
modelBuilder.Entity<Order>().OwnsOne(
    o => o.ShippingAddress,
    sa =>
    {
        sa.Property(p => p.Street).HasColumnName("ShipsToStreet");
        sa.Property(p => p.City).HasColumnName("ShipsToCity");
    });
```

##### 不同owned type共享相同的.NET type (两个owned属性的类型相同)

一个owned实体类型可以与另一个owned实体类型的.NET类型相同。因此。net类型可能不足以标识owned type。

在这种情形下，从owner指向owned实体的属性变成owned实体类型的定义导航`defining navigation`。从EF Core的角度来看，`defining navigation`是与.NET类型一起的类型标识。